# Differences in vulnerability counts across environments

Depending on the environment where the scan was done, `snyk test` may report different numbers of vulnerabilities.

Some dependencies found through the CLI may differ from those found through [Source Control Management (SCM) integrations](../../integrations/git-repository-scm-integrations/) that were set up using the Snyk Web UI.

There are also other possible causes of variation in vulnerabilities reported and those causes are summarized on this page.

## Scanning a local repository using the CLI

When you scan a local repository using the CLI, `snyk test` builds a dependency graph based on the source files in your build environment. When you run a test with the CLI using `snyk test` or make a snapshot for ongoing testing using `snyk monitor`, `snyk` looks at the dependencies as detected by the build tool (for example, Maven, npm, and so on) in order to see exactly what your project relies on. Private dependencies and the specifics of your build environment are all available to the build tool and so to `snyk` as well.

## Scanning a remote repository using the Web UI

When you scan a remote repository through an SCM integration using the Snyk Web UI, `snyk` infers the dependencies based on the files it can see. Therefore, a scan with the CLI may find more vulnerabilities than a scan through the Snyk Web UI.

Specifically, when `snyk` runs a test using an SCM integration such as the GitHub, GitLab, or Bitbucket server integration, `snyk` processes only the dependency manifest files for the project, for example, the `pom.xml`, `package-lock.json`, `Gemfile.lock` or other supported manifest file. The Snyk integration then infers the dependency graph of your project, approximating the operation of the build tool. A Snyk SCM Integration does not have access to private dependencies or the specifics of your build environment such as environment variables. Hence the results may be partial or slightly different compared to results from a scan using the Snyk CLI.

If the project was scanned with a lockfile, the results may be different from the results of scanning the project using a manifest file such as `package.json`. In general, the lockfile, if it exists, gives a much more deterministic view of the dependency graph. If a lockfile exists, it is always preferred by both the CLI and the SCM integrations and it allows the SCM integrations in particular to be much more accurate and similar to the CLI results. Therefore Snyk recommends using a lockfile if possible.

## Example of differing results from a CLI versus a Web UI scan

Consider this example:

* A sub-dependency requires `foo ^0.0.5` and during build `foo 0.0.6` was installed and had a vulnerability.
* Then `foo 0.0.7` was released patching the vulnerability after `foo 0.0.6` had been installed.
* According to `snyk` rules, an integration would assume that `foo 0.0.7` was installed, but in scanning the local project itself, `foo 0.0.7` is not taken into account.

**Note:** If the Snyk Web UI finds vulnerabilities and the CLI does not, try deleting the project from the project settings and re-importing the project. If the problem persists, submit a request to [Snyk support](https://support.snyk.io/hc/en-us/requests/new).

## Differences when scanning Maven, Gradle and sbt projects

In some package managers such as Maven, Gradle, and sbt, the Snyk SCM Integrations with GitHub, GitLab, Bitbucket, and so on rely on parsing the manifest file(s) to determine dependencies, whereas these package managers frequently rely on code to build the dependency tree.

Dependency overrides and mapping using code can sometimes cause the CLI to report a more accurate picture of dependencies than when `snyk` scans a project imported through the SCM.&#x20;

## Differences when scanning Golang projects

For Go Modules projects imported using an SCM integration, dependencies are resolved at the module level rather than the package level, as `snyk` does not have full access to the project source code.

This means you may see more issues reported for projects tested in the SCM, because `snyk` reports all vulnerabilities for each module rather than for the package(s) referenced in the source code.

## Differences when dev dependencies are being ignored

By default, `snyk` does not scan for dependencies listed in the dev dependencies section of the manifest file. You can enable scanning of dev dependencies in the following ways:

* Using the Snyk CLI, add the command line option `--dev`.
* Using the Snyk Web UI, click on **Settings** > **Languages** and select the language, for example, JavaScript and then select **Scan and fix dev dependencies** and the similar options for each language where such an option is available.

## Differences between Snyk scans and other tests

Snyk has more vulnerabilities in its database and may include them sooner than other databases do. Thus results may be different from tests done with other tools such as npm audit.

For more information see [Snyk Security Intelligence](https://snyk.io/snyk-intelligence-security/), Comprehensive security coverage section.

## Differences based on ignores set in the Web UI

Consider the case of setting ignores for certain vulnerabilities in a GitHub-originated project. When the same project is scanned with the CLI, the vulnerabilities that were ignored in the Web UI were found again and the build failed.

This occurred because ignores set in the Web UI are not duplicated in the local version of the project.

When you ignore a vulnerability using the CLI command `snyk ignore`, a `.snyk` policy file is created and saved locally in a `.snyk` file in the folder of your project. For information on how this file is created, see [The .snyk file](the-.snyk-file.md).

If you ignore a vulnerability through the Snyk Web UI, there is no mechanism for the ignore policy to be propagated from the Web UI to the local `.snyk` file in your project folder. This is why when you run `snyk test` after having ignored a vulnerability using the Snyk Web UI, you see that vulnerability in the CLI test results.

That is, ignores are not showing because you created them in the project imported from GitHub, while the CLI is running through the CLI integration with `snyk`. For `snyk`, the local project and the project in your account are two separate projects, so the ignores work only for the scans of GitHub.

If you want the ignores to be effective in the CLI, create the project from the CLI and apply the ignores in the CLI as follows:

1. Go to the root of your project and run `snyk monitor`.
2. Go to the Snyk Web UI; there is a new project that has the name of the project in the `package.json` file with the CLI icon.
3. Use the `snyk ignore` command to ignore the issue in the new project. You can also set ignores in the Web UI for a project created with the CLI.&#x20;
4. Run `snyk test` and `snyk monitor` and see if this solution ignores the issues you intend to ignore. Wait a minute or two to allow some caches to expire. Then look at the projects screen to see if what you intended is ignored.

An alternative is to run the `snyk ignore` command in the CLI and commit the resulting `.snyk` policy file to your branch in GitHub to apply ignores for all Snyk environments.

Note that you must commit the `.snyk` policy file each time you make a change in the ignore settings.

## Ignores and snyk monitor versus SCM projects

If a project is created with `snyk monito`r in the CLI and ignores are added in the Web UI, when you run `snyk test` on the local project, the ignores created in the Web UI are taken into account.

If the project is created by an SCM integration, there are two different projects, one created using the CLI and the other by an SCM integration. These two projects may have the same name but will have a different icon. If you add an Ignore in Web UI for the SCM project and test the project locally, the ignores added in the Web UI are not taken into account.

## When to scan with the CLI versus through the Snyk Web UI

When you need the most accurate possible results, scan using the CLI. When you can rely on an approximation of the vulnerabilities, scan using one of the SCM integrations in the Snyk Web UI.

Scanning through an SCM integration in the Web UI allows you to quickly scan a lot of repositories. Thus, for example, if a security manager scans 50 projects and 45 repositories are found to have no vulnerabilities, and five have vulnerabilities, the manager can ask developers to scan those five with the CLI and explore the results in greater depth.

The drawback is that for the other 45 repositories, there may be vulnerabilities that are missed because you are relying on an estimate.
